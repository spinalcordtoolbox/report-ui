import { useCallback, useMemo } from 'react'
import YAML, { Document, YAMLMap, YAMLSeq } from 'yaml'
import { saveAs } from 'file-saver'

import { Dataset } from '@/components/Datasets'
import Button from '@/components/Button'

type SegType =
  | 'FILES_LESION'
  | 'FILES_SEG'
  | 'FILES_REG'
  | 'FILES_TIMESERIES'
  | 'FILES_LABEL'
  | 'FILES_PMJ'
  | 'FILES_GMSEG'
  | 'FILE_KIND_UNKNOWN'

const SEG_CMD_TO_SEG_TYPE: { [k: string]: SegType } = {
  sct_analyze_lesion: 'FILES_LESION',
  sct_analyze_texture: 'FILES_SEG',
  sct_create_mask: 'FILES_SEG',
  sct_crop_image: 'FILES_SEG',
  sct_deepseg: 'FILES_SEG',
  sct_deepseg_gm: 'FILES_GMSEG',
  sct_deepseg_lesion: 'FILES_LESION',
  sct_deepseg_sc: 'FILES_SEG',
  sct_detect_pmj: 'FILES_PMJ',
  sct_dmri_moco: 'FILES_TIMESERIES',
  sct_fmri_moco: 'FILES_TIMESERIES',
  sct_image_stitch: 'FILES_REG',
  sct_label_utils: 'FILES_LABEL',
  sct_label_vertebrae: 'FILES_LABEL',
  sct_process_segmentation: 'FILES_SEG',
  sct_propseg: 'FILES_SEG',
  sct_register_multimodal: 'FILES_REG',
  sct_register_to_template: 'FILES_REG',
  sct_resample: 'FILES_SEG',
  sct_run_batch: 'FILES_SEG',
  sct_smooth_spinalcord: 'FILES_SEG',
  sct_straighten_spinalcord: 'FILES_SEG',
  sct_warp_template: 'FILES_REG',
}

type QcType = '❌' | '⚠️'

type PropTypes = {
  datasets: Dataset[]
}

export function YamlExport({ datasets }: PropTypes) {
  const exportYaml = useCallback(
    (qcType: QcType) => {
      let yaml: YAML.Document
      const matches = datasets.filter((d) => d.qc === qcType)

      if (!matches.length) {
        yaml = new Document()
        yaml.commentBefore = ' No rows matched'
      } else {
        yaml = new Document(new YAMLMap())
        matches.forEach((item) => {
          const { command } = item
          let item_path = yaml.createNode(`${item.path}/${item.inputFile}`)
          let segType: SegType
          if (command in SEG_CMD_TO_SEG_TYPE) {
            segType = SEG_CMD_TO_SEG_TYPE[command]
          } else {
            segType = 'FILE_KIND_UNKNOWN'
            item_path.comment = ` generated by ${item.cmdline}`
          }
          if (!yaml.get(segType)) {
            yaml.add({ key: segType, value: new YAMLSeq() })
          }
          yaml.addIn([segType], item_path)
        })
      }

      const yamlString = yaml.toString({ indent: 4, nullStr: '' })

      const blob = new Blob([yamlString], {
        type: 'text/plain;charset=utf-8',
      })

      const fname = qcType === '❌' ? 'qc_fail.yml' : 'qc_artifact.yml'

      saveAs(blob, fname)
    },
    [datasets],
  )

  const failsCount = useMemo(
    () => datasets.filter((d) => d.qc === '❌').length,
    [datasets],
  )
  const artifactsCount = useMemo(
    () => datasets.filter((d) => d.qc === '⚠️').length,
    [datasets],
  )

  const exportFails = useCallback(() => exportYaml('❌'), [exportYaml])
  const exportArtifacts = useCallback(() => exportYaml('⚠️'), [exportYaml])

  return (
    <>
      <Button onClick={exportFails} disabled={failsCount <= 0}>
        Save Fails
      </Button>
      <Button onClick={exportArtifacts} disabled={artifactsCount <= 0}>
        Save Artifacts
      </Button>
    </>
  )
}
